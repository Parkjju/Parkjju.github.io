<!DOCTYPE html>
<html lang="kr">
  <head>
    <head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- CSS only -->
  <link
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css"
    rel="stylesheet"
    integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC"
    crossorigin="anonymous"
  />
  <link href="/assets/CSS/style.css" rel="stylesheet" />
  <title>Parkjju's TIL</title>
</head>

  </head>

  <body>
    <div class="main_bar">
  <p class="main_bar--title"><a href="/">Parkjju's Today I Learned</a></p>

  <div class="main_bar--right">
    <!-- 검색창 -->
    <form action="" method="get" class="search-box">
      <i class="fas fa-search"></i>
      <input class="search-form" type="text" autocomplete="off" />
    </form>

    <!-- 링크버튼 -->
    <div
      class="main_bar--link"
      onclick="window.open('https://github.com/Parkjju')"
    >
      <p>Github</p>
      <i class="fas fa-external-link-alt"></i>
    </div>
  </div>
</div>
 <div class="menu-bar">
  <ul>
    <li
      class="sidebar-group sidebar-heading"
      data-bs-toggle="collapse"
      href="#collapse1"
      aria-expanded="false"
      aria-controls="collapse1"
      onclick="rotate(this)"
      role="menuitem"
    >
      <span class="sidebar-heading--name">개발 기록</span>
      <i class="fas fa-caret-right fa-xs"></i>
    </li>
    <ul class="collapse" id="collapse1">
      <li class="card card-body">
        <a href="./python" aria-current="page">Python 강좌(1) - Python 기본</a>
      </li>
      <li class="card card-body">
        <a href="./pythonHard" target="_self"
          >Python 강좌(2) - Python 제어문
        </a>
      </li>
    </ul>

    <li class="sidebar-group" role="menuitem">
      <p
        class="sidebar-heading"
        data-bs-toggle="collapse"
        href="#collapse2"
        aria-expanded="false"
        aria-controls="collapse2"
        onclick="rotate(this)"
      >
        <span class="sidebar-heading--name">Algorithm</span>
        <i class="fas fa-caret-right fa-xs"></i>
      </p>
    </li>
    <div class="collapse" id="collapse2">
      <div class="card card-body">
        <a href="./shortest" target="_self">
          Bellman Ford & Dijkstra 최단경로 알고리즘
        </a>
      </div>
      <div class="card card-body">
        <a href="./all-to-all" target="_self">all-to-all 최단경로 </a>
      </div>
      <div class="card card-body">
        <a href="./Recursion" target="_self"> Recursion 재귀 </a>
      </div>
      <div class="card card-body">
        <a href="./selection" target="_self"
          >선택문제 - k번째로 작은 수, Quickselection & MoM
        </a>
      </div>
      <div class="card card-body">
        <a href="./mom" target="_self"
          >MOM - Median of Medians 알고리즘 설명 + 수행시간
        </a>
      </div>
      <div class="card card-body">
        <a href="./divide" target="_self"
          >Divide and Conquer 알고리즘 설명 & 예시
        </a>
      </div>
    </div>

    <li class="sidebar-group" role="menuitem">
      <p
        class="sidebar-heading"
        data-bs-toggle="collapse"
        href="#collapse3"
        aria-expanded="false"
        aria-controls="collapse3"
        onclick="rotate(this)"
      >
        <span class="sidebar-heading--name">Data structure</span>
        <i class="fas fa-caret-right fa-xs"></i>
      </p>
    </li>
    <div class="collapse" id="collapse3">
      <div class="card card-body">
        <a href="./data_structure" target="_self">자료구조의 이해 </a>
        <a href="./sequential_structure" target="_self">선형 자료구조 </a>
        <a href="./hash_table" target="_self">해시 테이블 자료구조 </a>
        <a href="./stack_cal" target="_self"
          >스택을 이용하여 계산기 구현하기
        </a>
        <a href="./SinglyLinkedList" target="_self"
          >한 방향 연결리스트 연산 구현
        </a>
        <a href="./doublyLinkedList" target="_self"
          >양 방향 연결리스트 연산 구현
        </a>
        <a href="./pydict" target="_self">파이썬의 딕셔너리 작동방식 </a>
        <a href="./tree" target="_self">트리 자료구조 </a>
        <a href="./open_addressing" target="_self"
          >해시테이블 open addressing 실습
        </a>
        <a href="./heap" target="_self">heap 자료구조 </a>
        <a href="./union-find" target="_self">union find 자료구조 </a>
        <a href="./graph" target="_self">graph 자료구조 </a>
      </div>
    </div>

    <li class="sidebar-group" role="menuitem">
      <p
        class="sidebar-heading"
        data-bs-toggle="collapse"
        href="#collapse4"
        aria-expanded="false"
        aria-controls="collapse4"
        onclick="rotate(this)"
      >
        <span class="sidebar-heading--name">Git</span>
        <i class="fas fa-caret-right fa-xs"></i>
      </p>
    </li>
    <div class="collapse" id="collapse4">
      <div class="card card-body">Hello</div>
      <div class="card card-body">Hello2</div>
    </div>

    <li class="sidebar-group" role="menuitem">
      <p
        class="sidebar-heading"
        data-bs-toggle="collapse"
        href="#collapse5"
        aria-expanded="false"
        aria-controls="collapse5"
        onclick="rotate(this)"
      >
        <span class="sidebar-heading--name">Git</span>
        <i class="fas fa-caret-right fa-xs"></i>
      </p>
    </li>
    <div class="collapse" id="collapse5">
      <div class="card card-body">Hello</div>
      <div class="card card-body">Hello2</div>
    </div>

    <li class="sidebar-group" role="menuitem">
      <p
        class="sidebar-heading"
        data-bs-toggle="collapse"
        href="#collapse6"
        aria-expanded="false"
        aria-controls="collapse6"
        onclick="rotate(this)"
      >
        <span class="sidebar-heading--name">Git</span>
        <i class="fas fa-caret-right fa-xs"></i>
      </p>
    </li>
    <div class="collapse" id="collapse6">
      <div class="card card-body">Hello</div>
      <div class="card card-body">Hello2</div>
    </div>

    <li class="sidebar-group" role="menuitem">
      <p
        class="sidebar-heading"
        data-bs-toggle="collapse"
        href="#collapse7"
        aria-expanded="false"
        aria-controls="collapse7"
        onclick="rotate(this)"
      >
        <span class="sidebar-heading--name">Git</span>
        <i class="fas fa-caret-right fa-xs"></i>
      </p>
    </li>
    <div class="collapse" id="collapse7">
      <div class="card card-body">Hello</div>
      <div class="card card-body">Hello2</div>
    </div>

    <li class="sidebar-group" role="menuitem">
      <p
        class="sidebar-heading"
        data-bs-toggle="collapse"
        href="#collapse8"
        aria-expanded="false"
        aria-controls="collapse8"
        onclick="rotate(this)"
      >
        <span class="sidebar-heading--name">Git</span>
        <i class="fas fa-caret-right fa-xs"></i>
      </p>
    </li>
    <div class="collapse" id="collapse8">
      <div class="card card-body">Hello</div>
      <div class="card card-body">Hello2</div>
    </div>

    <li class="sidebar-group" role="menuitem">
      <p
        class="sidebar-heading"
        data-bs-toggle="collapse"
        href="#collapse9"
        aria-expanded="false"
        aria-controls="collapse9"
        onclick="rotate(this)"
      >
        <span class="sidebar-heading--name">Git</span>
        <i class="fas fa-caret-right fa-xs"></i>
      </p>
    </li>
    <div class="collapse" id="collapse9">
      <div class="card card-body">Hello</div>
      <div class="card card-body">Hello2</div>
    </div>

    <li class="sidebar-group" role="menuitem">
      <p
        class="sidebar-heading"
        data-bs-toggle="collapse"
        href="#collapse10"
        aria-expanded="false"
        aria-controls="collapse10"
        onclick="rotate(this)"
      >
        <span class="sidebar-heading--name">Git</span>
        <i class="fas fa-caret-right fa-xs"></i>
      </p>
    </li>
    <div class="collapse" id="collapse10">
      <div class="card card-body">Hello</div>
      <div class="card card-body">Hello2</div>
    </div>
  </ul>
</div>
 
    <main class="main-post">
  <h1 class="main-post--title">힙 자료구조</h1>
  <div class="line"></div>
  <section class="main-post--content"><h3 id="힙-성질을-만족하는-이진트리">힙 성질을 만족하는 이진트리</h3>

<ul>
  <li>
    <p>n개의 노드로 이루어진 이진트리 중 높이가 제일 작은 트리</p>
  </li>
  <li>
    <p>리스트 H=[ a,b,c,None,d,e,f ] -&gt; 자식노드가 없어도 공간을 차지한다고 생각.</p>

    <ul>
      <li>H[0]의 왼쪽 자식노드 =&gt; H[1]</li>
      <li>H[2]의 오른쪽 자식 노드 =&gt; H[2*2+2] (왼쪽 자식노드는 + 1)</li>
    </ul>
  </li>
  <li>일반화
    <ul>
      <li>H[k]의 왼쪽 자식노드 : H[2*k+1]</li>
      <li>H[k]의 오른쪽 자식노드 : H[2*k+2]</li>
      <li>H[k]의 부모노드 : H[(k-1)//2]</li>
    </ul>
  </li>
  <li>결론적으로, <strong>자식노드와 부모노드를 상수시간에 계산해낼 수 있다</strong></li>
  <li>단점) 3레벨의 자식노드들이 최 우측단 노드밖에 없다고 가정 -&gt; 불필요한 메모리를 낭비하게 됨.</li>
</ul>

<p><strong>Heap 성질이란?</strong></p>

<ul>
  <li>
    <p>모든 부모노드의 key값은 자식 노드의 key 값보다 작지 않다.</p>
  </li>
  <li>
    <p>예) A=[2,8,6,1,10,15,3,12,11] -&gt; 부모노드 2는 자식노드의 key보다 작음.</p>
  </li>
</ul>

<ol>
  <li>모양 -&gt; 리스트 표현법에서 좌측부터 끝까지 꽉 채워져 있는 상태(<strong>완전 이진트리</strong> -&gt; 오른쪽 자식노드부터 제거되었다고 가정하는 트리)</li>
  <li>heap성질 만족</li>
</ol>

<ul>
  <li>
    <p>리스트의 표현법을 트리로 해석하였을때 위의 두 조건을 만족하면 heap이다.</p>
  </li>
  <li>
    <p><strong>도출해낼 수 있는 결론</strong></p>

    <ul>
      <li>루트노드 -&gt; max-value, index-0 value</li>
    </ul>
  </li>
  <li>
    <p>구현하는 연산</p>
    <ol>
      <li>insert 연산 O(logn)</li>
      <li>find_max 연산 - return root_node (O(1))</li>
      <li>delete_max 연산 O(logn) -&gt; <strong>지우고 남은 노드들도 heap성질도 만족해야함!!!! - 적당한 배치 필요</strong></li>
    </ol>
  </li>
</ul>

<h3 id="make_heap-연산">make_heap 연산</h3>

<ul>
  <li>A = [2,8,6,1,10,15,3,12,11] 트리 (재배치를 통해 heap으로 만드는 연산이 make_heap연산)</li>
  <li><strong>heapify-down</strong>연산 구현이 우선되어야 함.
    <ol>
      <li>leaf노드를 연산에서 무시</li>
      <li>특정 노드의 자식 노드에 대해 *2+1, *2+2 연산을 통해 key값을 비교하여 <strong>부모 노드가 자식노드보다 작으면, 자식노드들 중에 더 큰 값으로 위치를 바꾼다</strong></li>
      <li>2번과정을 마치면 작은heap이 완성된 것.</li>
      <li>우측에서 좌측으로 순회하며 2번 과정을 계속해서 반복하다가, <strong>자식 노드와 바꾼 뒤에도 자식의 자식 노드보다 key값이 작으면 자식의 자식 노드와도 자리를 바꿔줘야함</strong> -&gt; 자식노드가 leaf일때까지.</li>
      <li>루트까지 마무리하면, 전체 heap이 만들어짐.</li>
    </ol>
  </li>
</ul>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code># pseudo code
make_heap(A):
    n = len(A)
    for k in range(n-1, -1, -1):
        # A[k] -&gt; heap 성질 만족하는 곳으로
        heapify_down(k,n) # k-&gt; A[k], heap원소의 갯수

heapify_down(k,n):
    # A[k]를 제자리로, n개의 원소를 지닌 트리
    while A[k] != leaf_node:
        L,R = 2*k+1, 2*k+2
        m = max_index(A[k],A[L], A[k])

        if k!=m: # maximum이 L이나 R이라는 뜻, 자식노드의 키값이 더 크다는 뜻
            A[k],A[m] = A[m],A[k]
            k=m
        else:
            break
</code></pre></div></div>

<ul>
  <li>
    <p>make_heap의 수행시간</p>

    <ul>
      <li>for문 k 호출을 n번 진행 X heapify_down수행시간</li>
      <li>n X heap의 height</li>
    </ul>
  </li>
  <li>
    <p>heapify_down의 수행시간</p>

    <ul>
      <li>worst case =&gt; root노드부터 가장 깊은 레벨의 leaf node까지 heapify_down</li>
      <li>heap의 높이에 비례하게됨.</li>
      <li>따라서, heapify_down의 수행시간 -&gt; <strong>heap의 height</strong></li>
    </ul>
  </li>
  <li>
    <p>heap의 height 계산</p>

    <ul>
      <li>root node -&gt; 1</li>
      <li>root node의 자식 노드 -&gt; 2</li>
      <li>자식의 자식의 자식의….. -&gt; 2^2…..</li>
      <li>마지막 레벨의 노드는 2^(h-1)부터 2^h 중에 있음.</li>
      <li>1+2+2^2+….+2^(h-1)+1 &lt;= n</li>
      <li>-&gt; 2^h &lt;= n</li>
      <li>-&gt; h &lt;= log(2)n</li>
    </ul>
  </li>
  <li>heapify_down : O(h) -&gt; O(logn)</li>
  <li>make_heap : O(nh) -&gt; O(nlogn) -&gt; <strong>실질적으로 O(n)에 수렴</strong> (sigma i=0 to h, 2^i*(h-i)) -&gt; O(n)
    <ul>
      <li>make_heap 수행시간 -&gt; sigma로 이루어진 수식을 멱급수 형태로 풀어주면 O(n)나옴</li>
    </ul>
  </li>
</ul>

<h3 id="insert와-delete_max-연산">insert와 delete_max 연산</h3>

<ul>
  <li>insert
    <ol>
      <li>A.append(14) (leaf노드로 추가)</li>
      <li>부모 노드와 비교 -&gt; 부모 노드보다 key값이 크면 위치 변경</li>
      <li>부모노드의 동일한 레벨의 노드와 key값 비교할 필요 X (just 부모노드랑)</li>
    </ol>
  </li>
  <li>heapify_up
    <ul>
      <li>A[k]를 root방향으로 이동하면서 heapify!</li>
    </ul>
  </li>
</ul>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code># pseudo code
heapify(k):
    # A[k]를 heapify.
    while k&gt;0 and A[(k-1)//2]&lt;A[k]: # root node이거나 부모노드의 키값이 자식노드의 키값보다 크면 break
        A[k],A[(k-1)//2]=A[(k-1)//2],A[k]
        k = (k-1)//2
</code></pre></div></div>

<ul>
  <li>수행시간 - 트리의 높이 h = log(2)n 만큼 진행 -&gt; O(logn)</li>
  <li>
    <p>A를 heap으로 만들기 위해서는 <strong>A에 make_heap을 호출하거나 - O(n)시간</strong>, <strong>insert를 n번 호출한다. - O(nlogn)시간</strong></p>
  </li>
  <li>
    <p>find_max</p>

    <ul>
      <li>return root node</li>
    </ul>
  </li>
  <li>delete_max - O(n)시간.
    <ol>
      <li>root node를 삭제한다.</li>
      <li>빈 root node를 채우는 방법!</li>
      <li>가장 마지막 노드를 root node로 보낸다.</li>
      <li>root node를 heapify_down 한다.</li>
    </ol>
  </li>
</ul>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>delete_max:
    if len(A)==0:
        return None
    key = A[0]
    A[0],A[len(A)-1] = A[len(A)-1],A[0]
    A.pop()
    heapify_down(index(0), len(A))
    return key
</code></pre></div></div>

<h3 id="update_key-연산">Update_key 연산</h3>

<ul>
  <li>old_key와 new_key가 들어있는 인덱스를 어떻게 찾는가?</li>
  <li>애초에 데이터를 key와 index를 함께 저장</li>
  <li>dictionary를 통해 D[key]를 입력 -&gt; index가 나오도록 저장</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># pseudo code
</span><span class="k">def</span> <span class="nf">Update_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">old_key</span><span class="p">,</span><span class="n">new_key</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">old_key</span><span class="o">&gt;</span><span class="n">new_key</span><span class="p">:</span>
        <span class="n">heapify_down</span><span class="p">(</span><span class="n">old_key</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">old_key</span><span class="o">&lt;</span><span class="n">new_key</span><span class="p">:</span>
        <span class="n">heapify_up</span><span class="p">(</span><span class="n">old_key</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="연산-정리">연산 정리</h3>

<ol>
  <li>make_heap: O(n), O(nlogn) - insert n번 or heap 구축</li>
  <li>insert : O(logn)</li>
  <li>find_max : O(1)</li>
  <li>delete_max : O(logn)</li>
  <li>heapify_down : O(h) = O(logn)</li>
  <li>heapify_up : O(h) = O(logn)</li>
</ol>

<ul>
  <li>search연산은 하나하나 값을 비교하는 것 외에는 heap 자료구조만의 특별한 search 존재 X</li>
  <li>
    <p>heap은 search의 효율성 X -&gt; <strong>insert, find_max, delete_max</strong>를 빠르게 진행하는 application에 적용!!!</p>
  </li>
  <li>
    <p><strong>min_heap?</strong></p>

    <ul>
      <li>부모 노드와 자식 노드의 key값 관계를 반대로 정의하면 됨.</li>
      <li>부모 노드의 key값이 자식 노드의 key값보다 작거나 같도록 정의!</li>
      <li>root node가 최소값이 될 것. -&gt; delete_min, find_min 파생</li>
    </ul>
  </li>
</ul>

<h3 id="heap_sort-알고리즘">heap_sort 알고리즘</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># pseudo code
</span><span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">idx</span><span class="o">=</span> <span class="n">get_max</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="c1"># A[0]..A[i]까지 최대값 -&gt; m에, 해당 인덱스는 m에 언패킹
</span>        <span class="n">A</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
</code></pre></div></div>

<ul>
  <li>get_max에 heap 자료구조를 이용할 때 수행시간이 효율적으로 줄어들게 됨</li>
</ul>
</section>
</main>


    <script src="https://use.fontawesome.com/releases/v5.15.3/js/all.js"></script>
    <!-- JavaScript Bundle with Popper -->
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js"
      integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM"
      crossorigin="anonymous"
    ></script>
    <script src="assets/js/sidebar-click-event.js"></script>
    <script src="//code.jquery.com/jquery-3.3.1.min.js"></script>
  </body>
</html>
