<!DOCTYPE html>
<html lang="kr">
  <head>
    <head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- CSS only -->
  <link
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css"
    rel="stylesheet"
    integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC"
    crossorigin="anonymous"
  />
  <link href="/assets/CSS/style.css" rel="stylesheet" />
  <title>Parkjju's TIL</title>
</head>

  </head>

  <body>
    <div class="main_bar">
  <p class="main_bar--title"><a href="/">Parkjju's Today I Learned</a></p>

  <div class="main_bar--right">
    <!-- 검색창 -->
    <form action="" method="get" class="search-box">
      <i class="fas fa-search"></i>
      <input class="search-form" type="text" autocomplete="off" />
    </form>

    <!-- 링크버튼 -->
    <div
      class="main_bar--link"
      onclick="window.open('https://github.com/Parkjju')"
    >
      <p>Github</p>
      <i class="fas fa-external-link-alt"></i>
    </div>
  </div>
</div>
 <div class="menu-bar">
  <ul>
    <li class="sidebar-group" role="menuitem">
      <p
        class="sidebar-heading"
        data-bs-toggle="collapse"
        href="#collapse5"
        aria-expanded="false"
        aria-controls="collapse5"
        onclick="rotate(this)"
      >
        <span class="sidebar-heading--name">Computer Science</span>
        <i class="fas fa-caret-right fa-xs"></i>
      </p>
    </li>
    <div class="collapse" id="collapse5">
      <div class="card card-body">
        <a href="./docker" target="_self">Docker란?</a>
      </div>
      <div class="card card-body">
        <a href="./domain" target="_self">Domain이란</a>
      </div>
      <div class="card card-body">
        <a href="./serverless" target="_self">Serverless</a>
      </div>
      <div class="card card-body">
        <a href="./library" target="_self">library vs framework</a>
      </div>
      <div class="card card-body">
        <a href="./api" target="_self">API 란?</a>
      </div>
      <div class="card card-body">
        <a href="./devops" target="_self">devops 정리</a>
      </div>
      <div class="card card-body">
        <a href="./web_request" target="_self">web요청과 응답과정</a>
      </div>
      <div class="card card-body">
        <a href="./block-chain" target="_self"
          >nomad coders 블록체인 시리즈 총정리</a
        >
      </div>
      <div class="card card-body">
        <a href="./begin" target="_self">coursera series - Digital Logic</a>
      </div>
      <div class="card card-body">
        <a href="./Module-Introduction" target="_self"
          >coursera series - Hardware</a
        >
      </div>
      <div class="card card-body">
        <a href="./OS" target="_self">coursera series - OS</a>
      </div>
      <div class="card card-body">
        <a href="./networking" target="_self">coursera series - networking</a>
      </div>
      <div class="card card-body">
        <a href="./software" target="_self">coursera series - software</a>
      </div>
    </div>

    <li class="sidebar-group" role="menuitem">
      <p
        class="sidebar-heading"
        data-bs-toggle="collapse"
        href="#collapse2"
        aria-expanded="false"
        aria-controls="collapse2"
        onclick="rotate(this)"
      >
        <span class="sidebar-heading--name">Algorithm</span>
        <i class="fas fa-caret-right fa-xs"></i>
      </p>
    </li>
    <div class="collapse" id="collapse2">
      <div class="card card-body">
        <a href="./shortest" target="_self">
          Bellman Ford & Dijkstra 최단경로 알고리즘
        </a>
      </div>
      <div class="card card-body">
        <a href="./all-to-all" target="_self">all-to-all 최단경로 </a>
      </div>
      <div class="card card-body">
        <a href="./Recursion" target="_self"> Recursion 재귀 </a>
      </div>
      <div class="card card-body">
        <a href="./selection" target="_self"
          >선택문제 - k번째로 작은 수, Quickselection & MoM
        </a>
      </div>
      <div class="card card-body">
        <a href="./mom" target="_self"
          >MOM - Median of Medians 알고리즘 설명 + 수행시간
        </a>
      </div>
      <div class="card card-body">
        <a href="./divide" target="_self"
          >Divide and Conquer 알고리즘 설명 & 예시
        </a>
      </div>
    </div>

    <li class="sidebar-group" role="menuitem">
      <p
        class="sidebar-heading"
        data-bs-toggle="collapse"
        href="#collapse3"
        aria-expanded="false"
        aria-controls="collapse3"
        onclick="rotate(this)"
      >
        <span class="sidebar-heading--name">Data structure</span>
        <i class="fas fa-caret-right fa-xs"></i>
      </p>
    </li>
    <div class="collapse" id="collapse3">
      <div class="card card-body">
        <a href="./data_structure" target="_self">자료구조의 이해 </a>
        <a href="./sequential_structure" target="_self">선형 자료구조 </a>
        <a href="./hash_table" target="_self">해시 테이블 자료구조 </a>
        <a href="./stack_cal" target="_self"
          >스택을 이용하여 계산기 구현하기
        </a>
        <a href="./SinglyLinkedList" target="_self"
          >한 방향 연결리스트 연산 구현
        </a>
        <a href="./doublyLinkedList" target="_self"
          >양 방향 연결리스트 연산 구현
        </a>
        <a href="./pydict" target="_self">파이썬의 딕셔너리 작동방식 </a>
        <a href="./tree" target="_self">트리 자료구조 </a>
        <a href="./open_addressing" target="_self"
          >해시테이블 open addressing 실습
        </a>
        <a href="./heap" target="_self">heap 자료구조 </a>
        <a href="./union-find" target="_self">union find 자료구조 </a>
        <a href="./graph" target="_self">graph 자료구조 </a>
      </div>
    </div>

    <li class="sidebar-group" role="menuitem">
      <p
        class="sidebar-heading"
        data-bs-toggle="collapse"
        href="#collapse4"
        aria-expanded="false"
        aria-controls="collapse4"
        onclick="rotate(this)"
      >
        <span class="sidebar-heading--name">Python</span>
        <i class="fas fa-caret-right fa-xs"></i>
      </p>
    </li>
    <div class="collapse" id="collapse4">
      <li class="sidebar-group" role="menuitem">
        <p
          class="sidebar-heading"
          data-bs-toggle="collapse"
          href="#pythonNewbie"
          aria-expanded="false"
          aria-controls="pythonNewbie"
          onclick="rotate(this)"
        >
          <span class="sidebar-heading--name">Python 초급</span>
          <!-- <i class="fas fa-caret-right fa-xs"></i> -->
        </p>
      </li>
      <div class="collapse" id="pythonNewbie">
        <div class="card card-body">
          <a href="./functions" target="_self">입출력과 변수 </a>
        </div>
        <div class="card card-body">
          <a href="./input_and_print" target="_self">간단한 함수 만들기 </a>
        </div>
        <div class="card card-body">
          <a href="./input_loop" target="_self"
            >프로그램 사용자로부터 입력받기 + 코드의 반복
          </a>
        </div>
        <div class="card card-body">
          <a href="./int_float_data" target="_self"
            >int형 데이터와 float형 데이터
          </a>
        </div>
        <div class="card card-body">
          <a href="./list_string" target="_self">리스트와 문자열 </a>
        </div>
        <div class="card card-body">
          <a href="./list_function" target="_self">리스트와 문자열의 함수들 </a>
        </div>
        <div class="card card-body">
          <a href="./TF" target="_self">True,False, if문과 형제들 </a>
        </div>
        <div class="card card-body">
          <a href="./for_while_loop" target="_self">while, 이중 for루프 </a>
        </div>
        <div class="card card-body">
          <a href="./tuple_range" target="_self">튜플과 레인지 </a>
        </div>
        <div class="card card-body">
          <a href="./functions_add" target="_self"
            >함수에 대한 추가적인 설명 - 디폴트값 등
          </a>
        </div>
        <div class="card card-body">
          <a href="./modules" target="_self">모듈(Modules) </a>
        </div>
        <div class="card card-body">
          <a href="./dictionary" target="_self">딕셔너리(Dictionary) </a>
        </div>
        <div class="card card-body">
          <a href="./class" target="_self">클래스와 객체 </a>
        </div>
        <div class="card card-body">
          <a href="./unexpect" target="_self">예외처리</a>
        </div>
      </div>
      <li class="sidebar-group" role="menuitem">
        <p
          class="sidebar-heading"
          data-bs-toggle="collapse"
          href="#pythonUser"
          aria-expanded="false"
          aria-controls="pythonUser"
          onclick="rotate(this)"
        >
          <span class="sidebar-heading--name">Python 중급</span>
          <!-- <i class="fas fa-caret-right fa-xs"></i> -->
        </p>
      </li>
      <div class="collapse" id="pythonUser">
        <div class="card card-body">
          <a href="./reference_count_garbage_collection" target="_self"
            >레퍼런스 카운트와 가비지 컬렉션
          </a>
        </div>
        <div class="card card-body">
          <a href="./immutable_mutable" target="_self"
            >수정 가능한 객체와 수정 불가능한 객체
          </a>
        </div>
        <div class="card card-body">
          <a href="./deep_shallow_copy" target="_self"
            >깊은 복사와 얕은 복사
          </a>
        </div>
        <div class="card card-body">
          <a href="./hide_dict" target="_self">정보 은닉과 dict</a>
        </div>
        <div class="card card-body">
          <a href="./property" target="_self">프로퍼티</a>
        </div>
        <div class="card card-body">
          <a href="./slots" target="_self">슬롯</a>
        </div>
        <div class="card card-body">
          <a href="./list_comprehension" target="_self">리스트 컴프리헨션</a>
        </div>
        <div class="card card-body">
          <a href="./iterable_iterator" target="_self"
            >Iterable 객체와 Iterator 객체</a
          >
        </div>
        <div class="card card-body">
          <a href="./lambda" target="_self"
            >객체처럼 다뤄지는 함수 그리고 람다</a
          >
        </div>
        <div class="card card-body">
          <a href="./map_and_filter" target="_self">map&filter</a>
        </div>
        <div class="card card-body">
          <a href="./func_comprehension" target="_self"
            >map&filter를 대신하는 리스트 컴프리헨션</a
          >
        </div>
        <div class="card card-body">
          <a href="./generator" target="_self">generator 함수</a>
        </div>
        <div class="card card-body">
          <a href="./generator_expression" target="_self"
            >generator expression</a
          >
        </div>
        <div class="card card-body">
          <a href="./tuple_packing" target="_self">튜플의 패킹과 언패킹</a>
        </div>
        <div class="card card-body">
          <a href="./named_tuple" target="_self">네임드 튜플</a>
        </div>
        <div class="card card-body">
          <a href="./prod_dict" target="_self">dict의 생성과 zip</a>
        </div>
        <div class="card card-body">
          <a href="./dict_lupin" target="_self"
            >dict의 루핑 기술과 컴프리헨션</a
          >
        </div>
        <div class="card card-body">
          <a href="./func_star_rule" target="_self"
            >함수 호출과 매개변수 선언에 있어서 *과 **의 사용규칙</a
          >
        </div>
        <div class="card card-body">
          <a href="./dict_defaultdict" target="_self">dict & defaultdict</a>
        </div>
        <div class="card card-body">
          <a href="./ordered_dict" target="_self">dict & OrderedDict</a>
        </div>
        <div class="card card-body">
          <a href="./set_frozenset" target="_self"
            >자료형 분류와 set&frozenset</a
          >
        </div>
        <div class="card card-body">
          <a href="./sort" target="_self">정렬 기술</a>
        </div>
        <div class="card card-body">
          <a href="./enumerate" target="_self">enumerate과 문자열 비교</a>
        </div>
        <div class="card card-body">
          <a href="./expression_comb" target="_self">표현식 기반 문자열 조합</a>
        </div>
        <div class="card card-body">
          <a href="./method_str" target="_self">메소드 기반 문자열 조합</a>
        </div>
        <div class="card card-body">
          <a href="./class_obj" target="_self">클래스와 객체의 본질</a>
        </div>
        <div class="card card-body">
          <a href="./inheritance" target="_self">상속</a>
        </div>
        <div class="card card-body">
          <a href="./isinstance" target="_self"
            >isinstance함수와 object클래스</a
          >
        </div>
        <div class="card card-body">
          <a href="./special_method" target="_self">스페셜 메소드</a>
        </div>
        <div class="card card-body">
          <a href="./operator_overload" target="_self">연산자 오버로딩</a>
        </div>
        <div class="card card-body">
          <a href="./nested_func" target="_self">네스티드 함수와 클로저</a>
        </div>
        <div class="card card-body">
          <a href="./decorator" target="_self">데코레이터</a>
        </div>
        <div class="card card-body">
          <a href="./class_method" target="_self"
            >클래스 메소드와 static 메소드</a
          >
        </div>
        <div class="card card-body">
          <a href="./name_main" target="_self">__name__ & __main__</a>
        </div>
      </div>
      <li class="sidebar-group" role="menuitem">
        <p
          class="sidebar-heading"
          data-bs-toggle="collapse"
          href="#pythonAdditional"
          aria-expanded="false"
          aria-controls="pythonAdditional"
          onclick="rotate(this)"
        >
          <span class="sidebar-heading--name">Python 추가 내용</span>
          <!-- <i class="fas fa-caret-right fa-xs"></i> -->
        </p>
      </li>
      <div class="collapse" id="pythonAdditional">
        <div class="card card-body">
          <a href="./dataframe" target="_self">Python 데이터 프레임 </a>
        </div>
        <div class="card card-body">
          <a href="./sqlAlchemy" target="_self"
            >Python SQL alchemy를 통해 mysql 연동하기
          </a>
        </div>
        <div class="card card-body">
          <a href="./join" target="_self"
            >Python 문자열 자르고 합치기 - join, split함수</a
          >
        </div>
        <div class="card card-body">
          <a href="./getitem" target="_self"
            >Python getitem, setitem 스페셜메소드</a
          >
        </div>
        <div class="card card-body">
          <a href="./pylance" target="_self"
            >Pylance Unresolved import warnings 트러블슈팅</a
          >
        </div>
        <div class="card card-body">
          <a href="./django-css" target="_self"
            >Python django - How to add css to django application</a
          >
        </div>
      </div>
    </div>

    <li class="sidebar-group" role="menuitem">
      <p
        class="sidebar-heading"
        data-bs-toggle="collapse"
        href="#collapse6"
        aria-expanded="false"
        aria-controls="collapse6"
        onclick="rotate(this)"
      >
        <span class="sidebar-heading--name">CSS</span>
        <i class="fas fa-caret-right fa-xs"></i>
      </p>
    </li>
    <div class="collapse" id="collapse6">
      <div class="card card-body">
        <a href="./CSS_begin" target="_self"
          >CSS 기초 - block ~ Selector, state</a
        >
      </div>
      <div class="card card-body">
        <a href="./CSS_Advanced" target="_self"
          >CSS Transition, transform, animation</a
        >
      </div>
      <div class="card card-body">
        <a href="./CSS_additional" target="_self"
          >CSS Icon, Block Element Modifier, Font</a
        >
      </div>
      <div class="card card-body">
        <a href="./resetCSS" target="_self">reset CSS</a>
      </div>
      <div class="card card-body">
        <a href="./cssbox" target="_self"
          >CSS box, text-transformation, z-index, flex-children,
          forwards-animation, will change</a
        >
      </div>
      <div class="card card-body">
        <a href="./textarea" target="_self"
          >CSS autocomplete, textarea resize, div에 onclick줘서 링크걸기</a
        >
      </div>
      <div class="card card-body">
        <a href="./bootstrap" target="_self"
          >bootstrap 요소 클래스이름 충돌 관련 이슈 정리</a
        >
      </div>
      <div class="card card-body">
        <a href="./collapse" target="_self">bootstrap collapse이용하기</a>
      </div>
    </div>

    <li class="sidebar-group" role="menuitem">
      <p
        class="sidebar-heading"
        data-bs-toggle="collapse"
        href="#collapse7"
        aria-expanded="false"
        aria-controls="collapse7"
        onclick="rotate(this)"
      >
        <span class="sidebar-heading--name">Git</span>
        <i class="fas fa-caret-right fa-xs"></i>
      </p>
    </li>
    <div class="collapse" id="collapse7">
      <div class="card card-body">
        <a href="./github_page" target="_self">github페이지 제작하기</a>
      </div>
      <div class="card card-body">
        <a href="./git_command" target="_self">git 명령어 모음 (2021.02.08)</a>
      </div>
      <div class="card card-body">
        <a href="./gitignore" target="_self"
          >git 레포지토리 방문자 수 표시 (꾸미기)</a
        >
      </div>
      <div class="card card-body">
        <a href="./git_fetch" target="_self">git fetch & git pull</a>
      </div>
      <div class="card card-body">
        <a href="./git_submodule" target="_self">git submodule 총정리</a>
      </div>
    </div>

    <li class="sidebar-group" role="menuitem">
      <p
        class="sidebar-heading"
        data-bs-toggle="collapse"
        href="#collapse8"
        aria-expanded="false"
        aria-controls="collapse8"
        onclick="rotate(this)"
      >
        <span class="sidebar-heading--name">Git</span>
        <i class="fas fa-caret-right fa-xs"></i>
      </p>
    </li>
    <div class="collapse" id="collapse8">
      <div class="card card-body">Hello</div>
      <div class="card card-body">Hello2</div>
    </div>

    <li class="sidebar-group" role="menuitem">
      <p
        class="sidebar-heading"
        data-bs-toggle="collapse"
        href="#collapse10"
        aria-expanded="false"
        aria-controls="collapse10"
        onclick="rotate(this)"
      >
        <span class="sidebar-heading--name">HUFS 모각코 기록</span>
        <i class="fas fa-caret-right fa-xs"></i>
      </p>
    </li>
    <div class="collapse" id="collapse10">
      <div class="card card-body">
        <a href="./design" target="_self">2021.07 week2 </a>
      </div>
    </div>
    <!-- <li class="sidebar-group" role="menuitem">
  <p
    class="sidebar-heading"
    data-bs-toggle="collapse"
    href="#collapse9"
    aria-expanded="false"
    aria-controls="collapse9"
    onclick="rotate(this)"
  >
    <span class="sidebar-heading--name">Git</span>
    <i class="fas fa-caret-right fa-xs"></i>
  </p>
</li>
<div class="collapse" id="collapse9">
  <div class="card card-body">Hello</div>
  <div class="card card-body">Hello2</div>
</div> -->
  </ul>
</div>
 
    <main class="main-post">
  <h1 class="main-post--title">트리 자료구조</h1>
  <div class="line"></div>
  <section class="main-post--content"><h3 id="트리란">트리란?</h3>

<ul>
  <li>지금까지 해왔던 자료구조는 <strong>링크를 따라 순차적으로 움직이는 sequential structure</strong></li>
  <li>앞으로 배우게 되는 자료구조는 <strong>부모-자식노드 관계에 따라 움직이게 됨. 상-하</strong></li>
</ul>

<h3 id="이진트리-용어들">이진트리 용어들</h3>

<ol>
  <li>루트 노드 (root) - 가장 상위 노드</li>
  <li>링크(link), 에지(edge) - 각 노드를 서로 이어주는 선</li>
  <li>리프 노드 (leaf) - 각 링크의 가장 하위 노드</li>
  <li>레벨 (level) - 부모 노드와 자식 노드 사이의 간격 하나가 1레벨. (루트 노드는 레벨 0 부터 시작)</li>
  <li>트리의 높이 - 루트 노드로부터 가장 하위 리프 노드까지 필요한 링크의 수 (루트 노드와 가장 하위 리프 노드의 레벨 차이)</li>
  <li>경로(path) - 어떤 노드v ~ w까지 거쳐가는 노드들 (루트 3 -&gt; 2 -&gt; 7 -&gt; 8 -&gt; 12)</li>
  <li>경로 길이(path length) - 경로의 에지 개수</li>
  <li>부모 노드 (parent node) - 특정 노드의 바로 상위 노드</li>
  <li>자식 노드 (child node) - 특정 노드의 바로 하위 노드</li>
  <li>형제 노드 - 부모 노드가 동일한 노드</li>
</ol>

<h3 id="표현법">표현법</h3>

<p><img src="/assets/images/tree.jpg" width="40%" height="40%" /></p>

<ul>
  <li>
    <p>리스트 - A = [ a,b,c,None,d,e,f,None,None,h,…… ]</p>

    <ol>
      <li>루트 노드로부터 좌-&gt;우 방향으로 순회하면서 리스트에 값을 저장.</li>
      <li>레벨이 증가할 때 해당 레벨만큼 필요한 자식 노드의 개수를 index 계산하여 무슨 레벨인지 파악
        <ul>
          <li>ex) 레벨이 2인 노드에 접근 -&gt; 리스트의 인덱스 범위가 (2^2-1 ~ 2^3-1 까지)</li>
        </ul>
      </li>
      <li>노드에 값이 저장되어 있지 않으면 None 저장</li>
    </ol>
  </li>
  <li>
    <p>리스트2 -&gt; <strong>재귀적 표현</strong> A=[ a, [ a의 부트리 ], [ a의 오른쪽 부트리 ] ….]</p>

    <ul>
      <li>[a, [b, [], [d, [ ], [ ] ], [ c, [e, [ ], [ ] ]]…….]</li>
    </ul>
  </li>
  <li>
    <p>노드 class를 정의</p>
    <ul>
      <li>key</li>
      <li>자식 노드를 가리킬 link (left, right)</li>
      <li>부모 노드를 가리킬 parents</li>
      <li>value 등등ㅇ.. 기타의 것들</li>
    </ul>
  </li>
</ul>

<h3 id="이진-트리-binary-tree">이진 트리 (Binary Tree)</h3>

<ul>
  <li>
    <p>표현법</p>

    <ol>
      <li>이진트리 -&gt; 배열, 리스트 (heap)</li>
      <li>노드와 링크를 직접적으로 표현 (노드 클래스를 구성) - Node, Binary Tree class</li>
    </ol>
  </li>
  <li>
    <p>노드 클래스의 선언</p>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">key</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">key</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

    <span class="n">a</span><span class="p">.</span><span class="n">left</span><span class="o">=</span><span class="n">b</span>
    <span class="n">a</span><span class="p">.</span><span class="n">right</span><span class="o">=</span><span class="n">c</span>
    <span class="n">b</span><span class="p">.</span><span class="n">parent</span><span class="o">=</span><span class="n">a</span>
    <span class="n">c</span><span class="p">.</span><span class="n">parent</span><span class="o">=</span><span class="n">a</span>
    <span class="n">b</span><span class="p">.</span><span class="n">right</span><span class="o">=</span><span class="n">d</span>
    <span class="n">d</span><span class="p">.</span><span class="n">parent</span><span class="o">=</span><span class="n">b</span>
</code></pre></div></div>

<p><strong>순회 (Traverse)</strong></p>

<ol>
  <li>preorder</li>
  <li>inorder</li>
  <li>postorder</li>
</ol>

<ul>
  <li>이진트리 순회 (traversal) : 이진트리 노드의 key값을 빠짐없이 출력하는 방법 -&gt; <strong>재귀적으로 구현!</strong></li>
  <li>M노드 : 자기자신, L : M의 left subtree, R : M의 Right subtree</li>
</ul>

<ol>
  <li>preorder : M -&gt; L -&gt; R 순서</li>
  <li>inorder : L -&gt; M -&gt; R 순서</li>
  <li>postorder : L -&gt; R -&gt; M 순서</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">key</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">preorder</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c1"># self -&gt; 현재 방문중인 노드
</span>        <span class="k">if</span> <span class="bp">self</span><span class="o">!=</span><span class="bp">None</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">key</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">preorder</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">preorder</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">inorder</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">!=</span><span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">inorder</span><span class="p">()</span>
            <span class="k">print</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">key</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">inorder</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">postorder</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">!=</span><span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">postorder</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">postorder</span><span class="p">()</span>
            <span class="k">print</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">key</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>상황가정) 이진트리의 모양을 모르는 상태.
    <ol>
      <li>preorder : F B A D C E G I H</li>
      <li>inorder : A B C D E F G H I</li>
    </ol>
  </li>
  <li>
    <p>이로부터 원래의 이진트리의 모양을 복원하는 작업 -&gt; <strong>reconstruct</strong> - Inorder를 포함하여, preorder와 postorder 중 순서 개념을 알고 있는 상태로 이진트리 배열이 주어지면 reconstruct가 가능하다.</p>
  </li>
  <li>위의 상황가정의 경우 reconstruct가 가능!!</li>
</ul>

<h3 id="이진-탐색-트리binary-search-tree">이진 탐색 트리(Binary search Tree)</h3>

<ul>
  <li>탐색 기능에 효율적으로 이용되는 자료구조</li>
  <li>각 노드의 왼쪽 subtree의 key값은 노드의 key값보다 작거나 같아야함.</li>
  <li>각 노드의 오른쪽 subtree의 key값은 노드의 key값보다 커야함.</li>
  <li><code class="language-plaintext highlighter-rouge">A = [15,4,20,None,2,17,32,None,None,None,19,None,None]</code></li>
  <li>
    <p><strong>루트노드 뿐만 아니라 모든 노드에 있어서 해당 규칙이 적용되어야 함.</strong></p>
  </li>
  <li>
    <p>15(루트 노드) &gt; 왼쪽 subtree(4), 15(루트 노드) &lt; 오른쪽 subtree(20)</p>
  </li>
  <li>
    <p>search(19) -&gt; 루트부터(15) 시작 - 15보다 크므로 오른쪽 subtree -&gt; 20보다 작음 - 20의 왼쪽 subtree -&gt; …..</p>
  </li>
  <li>level by level로 내려감 -&gt; 한 레벨마다 작을 지 클 지 판단됨 -&gt; O(h), h==height.</li>
  <li>트리 자료구조 -&gt; height를 최대한 작게 유지 !!!</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">BST</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">root</span><span class="o">=</span><span class="bp">None</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">size</span><span class="o">=</span><span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">size</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">root</span><span class="p">.</span><span class="n">__iter__</span><span class="p">()</span> <span class="c1"># Node class의 iter 스페셜메소드 호출, BST class 말고!!!
</span>    <span class="c1"># iter메소드는 제너레이터로 정의하기
</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">BST</span><span class="p">()</span>
<span class="n">T</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
<span class="n">T</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="c1">#       15
#   4       None, 4가 15의 왼쪽subtree로 들어가야함. 그렇게 되도록 insert메소드를 구현!!
</span></code></pre></div></div>

<ul>
  <li>find_location 메소드</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">BST</span><span class="p">:</span>
    <span class="c1"># .....
</span>    <span class="k">def</span> <span class="nf">find_loc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">key</span><span class="p">):</span> <span class="c1"># key 값 노드가 있다면 해당 노드를 return, 없다면 삽입될 위치의 부모노드를 리턴
</span>        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">size</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">None</span> <span class="c1"># 한방향 연결리스트 tail찾기와 비슷한 방식
</span>        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">root</span>
        <span class="k">while</span> <span class="n">v</span><span class="o">!=</span><span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">v</span><span class="p">.</span><span class="n">key</span><span class="o">==</span><span class="n">key</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">v</span>
            <span class="k">elif</span> <span class="n">v</span><span class="p">.</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">key</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">v</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">right</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">v</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">left</span>
        <span class="c1"># while을 빠져나옴 -&gt;그 동안 따라왔던 부모노드 p를 리턴.
</span>        <span class="k">return</span> <span class="n">p</span>

    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">key</span><span class="p">):</span>
        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">find_loc</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">v</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">key</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">find_loc</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="c1"># : O(h) -&gt; 상수시간
</span>        <span class="c1"># p와 v의 링크를 달아줌
</span>        <span class="k">if</span> <span class="n">p</span><span class="o">==</span><span class="bp">None</span> <span class="ow">or</span> <span class="n">p</span><span class="p">.</span><span class="n">key</span><span class="o">!=</span><span class="n">key</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">v</span> <span class="c1"># p는 부모노드인데, None이므로 루트노드
</span>            <span class="k">else</span><span class="p">:</span> <span class="c1"># p가 루트노드가 아니면서, p의 key값이 insert할 key와 값이 다르다. - 정상적인 상황
</span>            <span class="c1"># insert할 key의 왼쪽에 들어갈 지, 오른쪽에 들어갈 지 모르는 상황
</span>                <span class="n">v</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">p</span>
                <span class="k">if</span> <span class="n">p</span><span class="p">.</span><span class="n">key</span> <span class="o">&gt;</span> <span class="n">key</span><span class="p">:</span>
                    <span class="n">p</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">v</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">p</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">v</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">size</span><span class="o">+=</span><span class="mi">1</span>
            <span class="k">return</span> <span class="n">v</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"key is already in tree"</span><span class="p">)</span> <span class="c1"># tree에 존재하는 key값을 다시 insert하려는 시도를 했다고 알려주는 부분
</span>            <span class="k">return</span> <span class="n">p</span>
</code></pre></div></div>

<ul>
  <li>
    <p>삭제연산(delete) : deleteByMerging, deleteByCopying</p>

    <ul>
      <li>deleteByMerging(self,x) -&gt; 노드 x를 삭제.</li>
      <li>deleteByCopying</li>
    </ul>
  </li>
  <li>deleteByMerging(self,x)
    <ul>
      <li>왼쪽 subtree를 L, 오른쪽 subtree를 R</li>
      <li>삭제한 x 자리에 L이 오도록 함</li>
      <li>가장 큰 key값을 가진 노드를 m이라고 할때 해당 노드에 R을 연결한다.</li>
      <li>L의 루트노드와 삭제한 x노드의 부모 노드와 link update</li>
    </ul>
  </li>
  <li>특수한 경우
    <ol>
      <li>a==None -&gt; b가 x를 대체</li>
      <li>x == root -&gt; x가 트리의 루트노드가 아니면 L이 그냥 x를 대체하면 됨</li>
    </ol>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># pseudo code
</span><span class="k">def</span> <span class="nf">deleteByMerging</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">left</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">right</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">x자리를</span> <span class="n">대체할</span> <span class="n">노드</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">L에서</span> <span class="n">key가</span> <span class="n">가장</span> <span class="n">큰</span> <span class="n">노드</span> <span class="c1"># L에서 key값이 가장 큰 노드
</span>    <span class="n">pt</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">parent</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">!=</span><span class="bp">None</span><span class="p">:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">a</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">a</span>
        <span class="k">while</span> <span class="n">m</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">right</span>
        <span class="k">if</span> <span class="n">b</span><span class="o">!=</span><span class="bp">None</span><span class="p">:</span>
            <span class="n">b</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">m</span>
            <span class="n">m</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">b</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># a==None
</span>            <span class="n">c</span> <span class="o">=</span> <span class="n">b</span>
        <span class="c1"># x를 대체한 뒤에 x의 부모와 대체한 노드의 링크를 업데이트
</span>
        <span class="k">if</span> <span class="n">pt</span><span class="o">!=</span><span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span><span class="p">:</span>
                <span class="n">c</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">pt</span>
            <span class="k">if</span> <span class="n">pt</span><span class="p">.</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">key</span><span class="p">:</span>
                <span class="n">pt</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">c</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pt</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">c</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># x.parent==None -&gt; 루트노드
</span>            <span class="bp">self</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">c</span>
            <span class="k">if</span> <span class="n">c</span><span class="p">:</span> <span class="c1"># c가 none이 아니어야함
</span>                <span class="n">c</span><span class="p">.</span><span class="n">parent</span><span class="o">=</span><span class="bp">None</span>

        <span class="bp">self</span><span class="p">.</span><span class="n">size</span> <span class="o">-=</span> <span class="mi">1</span>
</code></pre></div></div>

<ul>
  <li>
    <p>deleteByCopying</p>

    <ul>
      <li>L이 존재
        <ol>
          <li>L에서 가장 큰 값을 갖는 노드 y를 찾는다</li>
          <li>y의 key값을 x의 key값으로 카피</li>
          <li>y의 left subtree가 존재하면, y의 위치로 올린다.</li>
        </ol>
      </li>
      <li>L이 존재하지 않고, R이 존재하는 경우
        <ol>
          <li>R에서 가장 작은 값을 갖는 노드 y를 찾는다</li>
          <li>y의 key값을 x의 key값으로 카피한다.</li>
          <li>y의 right subtree가 존재하면, y의 위치로 올린다.</li>
        </ol>
      </li>
      <li>삭제할 노드가 root인 경우</li>
    </ul>
  </li>
  <li>
    <p>삭제 및 연산수행을 진행할 때에 각 노드마다 height정보를 관리한다면 update해야하는 경우 생각하여 진행 (추가 및 삭제된 노드 대상과 관련된 노드만 확인하면됨)</p>
  </li>
  <li>
    <p><strong>deleteByMerging, deleteByCopying 수행시간</strong></p>

    <ul>
      <li>두 함수 모두 L, 즉 삭제할 x노드의 left subtree의 maximum key를 찾는 데에 가장 많은 시간을 사용한다.</li>
      <li>최악의 경우 O(h)시간</li>
    </ul>
  </li>
  <li>
    <p>따라서 이진탐색트리에 있어서 insert, search, delete-merging and copying에 있어서 모두 최악의 경우 O(h)시간이 걸린다.</p>
    <ul>
      <li>이진 탐색트리의 h에 있어서 수행시간의 차이가 분명 존재할 것이다.</li>
      <li>h를 최소화 하도록 강제적으로 하는 이진탐색트리를 <strong>balanced-binary tree</strong>라고 함.</li>
    </ul>
  </li>
</ul>

<h4 id="균형이진탐색트리-balanced-binary-tree">균형이진탐색트리 balanced-binary tree</h4>

<ul>
  <li>
    <p>균형이진탐색트리 - 트리의 높이가 로그의 밑이 2인 logn만큼 비례되어 형성되는 트리</p>
  </li>
  <li>
    <p>트리의 높이를 줄이는 연산 - <strong>Rotation - 회전</strong> * Right rotation - left subtree의 높이가 더 깊을때 진행.
<img src="images/right-rotation.jpg" height="60%" width="60%" /></p>
  </li>
  <li>
    <p>rotateRight정의</p>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">rotateRight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">z</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">z</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">z</span><span class="p">.</span><span class="n">left</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">==</span><span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">right</span>
    <span class="n">x</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">z</span><span class="p">.</span><span class="n">parent</span>
    <span class="k">if</span> <span class="n">z</span><span class="p">.</span><span class="n">parent</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">z</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">left</span> <span class="o">==</span> <span class="n">z</span><span class="p">:</span>
            <span class="n">z</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">z</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">x</span>
    <span class="n">x</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">z</span>
    <span class="n">z</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">x</span>
    <span class="n">z</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">b</span>
    <span class="k">if</span> <span class="n">b</span><span class="p">:</span>
        <span class="n">b</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">z</span>
    <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">root</span> <span class="o">==</span> <span class="n">z</span><span class="p">:</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">x</span>
</code></pre></div></div>

<h4 id="avl-트리-adelson-velsky-landis">AVL 트리 (Adelson-Velsky, Landis)</h4>

<ul>
  <li>AVL트리란? 모든 노드에 대해서 각 노드의 left subtree와 right subtree의 높이 차가 1이하인 BST</li>
  <li>
    <p>AVL 트리는 n개의 노드에 대해서 항상 높이가 logn 시간으로 만들어지는가?</p>
  </li>
  <li>proof
    <ol>
      <li>h = 0 AVL -&gt; 루트노드가 AVL트리가됨</li>
      <li>h = 1
        <ul>
          <li>root - left, root - right, root - right &amp; left</li>
          <li>세 트리 모두 노드 수가 2,3개 이므로 logn 시간에 높이 형성</li>
        </ul>
      </li>
      <li>h = 2
        <ul>
          <li>AVL정의에 입각하여 높이를 형성하여 확인해보기..</li>
        </ul>
      </li>
      <li>높이의 일반화 -&gt; 각 높이에 따라 노드 수가 최소인 경우를 생각
        <ul>
          <li>루트노드로부터 left subtree와 right subtree의 높이 차가 1인 경우</li>
          <li>N_h = 높이가 h인 AVL트리 중에서 최소 노드의 개수</li>
          <li>N_0 = 1, N_1 = 2, N_2 = 4, N_3 = 7</li>
          <li>N_h -&gt; left subtree의 갯수 N_h-1 &amp; right subtree의 갯수 N_h-2 =&gt; N_h = N_h-1 + N_h-2 + 1</li>
          <li>N_h &gt;= 2*N_h-2 + 1 &gt;= 2*N_h-2</li>
          <li>N_h &gt;= 2*N_h-2 &gt;= 2*(2*N_h-4)</li>
          <li>……</li>
          <li>2^(h/2)*N_0 = 2^(h/2)</li>
          <li>N_h &gt;= 2^(h/2)</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>결론 - 높이 h이고 노드 갯수가 n인 AVL트리를 가정
    <ul>
      <li>h &lt;= c*log2(n)을 증명?</li>
      <li>n &gt;= N_h &gt;= 2^(h/2)</li>
      <li>h/2 &lt;= log2(n)</li>
      <li>h &lt;= 2*log2(n) =&gt; h = O(log2(n))</li>
    </ul>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="c1"># BST와 동일 + key, left, right, parent, height추가해야됨
</span><span class="k">class</span> <span class="nc">BST</span><span class="p">:</span>
    <span class="c1">#insert, deleteByMerging, search, deleteByCopying활용하는 BST 잘 이용하면됨.
</span>    <span class="c1">#insert와 deleteBymerging&amp;Copy는 height 변하는 노드에 대해 Update하도록 추가 구현 필요
</span>    <span class="c1"># + insert및 delete시 AVL정의를 유지하지 못하는 경우에 대해 처리는 나중에
</span><span class="k">class</span> <span class="nc">AVL</span><span class="p">(</span><span class="n">BST</span><span class="p">):</span>
    <span class="c1"># BST상속 - git정리내용 참고
</span>    <span class="c1"># init함수 없어도 됨 - BST클래스에서 구현해놓았기 때문
</span>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">v</span> <span class="o">=</span> <span class="nb">super</span><span class="p">.(</span><span class="n">AVL</span><span class="p">,</span><span class="bp">self</span><span class="p">).</span><span class="n">insert</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="c1"># AVL클래스의 self객체에 대하여 부모 클래스의 메소드인 insert메소드를 호출해라~
</span>        <span class="c1"># v의 삽입전, v의 삽입으로 인해 AVL정의가 무너지는 경우를 생각하자 - rebalance
</span>        <span class="c1"># 1. find x,y,z -&gt; 처음으로 AVL조건이 깨진 노드
</span>        <span class="n">w</span> <span class="o">=</span> <span class="n">rebalance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">w</span><span class="p">.</span><span class="n">parent</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">w</span>

</code></pre></div></div>

<ul>
  <li>
    <p>rebalance 이미지 - 신찬수교수님 유튜브 AVL강의
<img src="/assets/rotate.png" width="60%" height="60%" /></p>
  </li>
  <li>
    <p>z노드 - insert된 노드로부터 거슬로 올라가다가 가장 처음으로 AVL조건에 위배되는 노드 . x와 y는 leaf노드의 조상이면서 z의 자식노드(z-y-x)</p>
  </li>
  <li>insert이후 rebalance 1회 또는 2회를 진행하면 AVL을 만족하게됨.</li>
  <li>
    <p>AVL에서 insert 수행시간 -&gt; super의 insert -&gt; O(h) = O(logn)</p>

    <ul>
      <li>find -&gt; O(logn)</li>
      <li>rebalance -&gt; O(1)</li>
      <li>self.root=w -&gt; O(1)</li>
    </ul>
  </li>
  <li>
    <p>delete연산
<img src="images/delete.png" width="60%" height="60%" /></p>
  </li>
  <li>insert에서는 insert된 leaf node로부터 거슬러 올라가 rebalance를 진행했다면, delete는 삭제 이후 반대쪽 subtree(더 무거운 부트리)로부터 노드를 나눠받아 rebalance를 진행한다.</li>
  <li>delete 이후 rebalance를 진행하였는데, rebalance를 마친 후의 tree의 부모 노드 입장에서 AVL이 만족되지 않는 상황이 발생 (그림 3)
    <ul>
      <li>AVL 만족이 루트노드까지 이루어지는지 확인해야함.</li>
      <li>insert에서 1회 및 2회에서 rebalance가 마무리지어진다면 O(1)</li>
      <li>delete에서는 최악의 경우 높이만큼 rotation을 진행 O(logn)</li>
    </ul>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#pseudo code
</span><span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">u</span><span class="p">):</span>
    <span class="n">v</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">AVL</span><span class="p">,</span><span class="bp">self</span><span class="p">).</span><span class="n">deleteByCopying</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="c1"># u라는 노드를 지우면, u노드 삭제 이후로 AVL조건이 꺠질 수 있는 가능성이 가장 큰 노드를 반환하도록 설계
</span>    <span class="k">while</span> <span class="n">v</span><span class="o">!=</span><span class="bp">None</span><span class="p">:</span> <span class="c1">#루프까지 AVL만족하도록 check
</span>        <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">balanced</span><span class="p">:</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">v</span>
            <span class="k">if</span> <span class="n">z</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">height</span> <span class="o">&gt;=</span> <span class="n">z</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">height</span><span class="p">:</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">z</span><span class="p">.</span><span class="n">left</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">z</span><span class="p">.</span><span class="n">right</span>

            <span class="k">if</span> <span class="n">y</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">height</span> <span class="o">&gt;=</span> <span class="n">y</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">height</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="p">.</span><span class="n">left</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="p">.</span><span class="n">right</span>
            <span class="c1"># 여기까지 x-y-z관계가 설정됨
</span>            <span class="n">v</span> <span class="o">=</span> <span class="n">rebalance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">)</span> <span class="c1"># x-y-z가 일직선 연결 -&gt; 1회 rotation, 중간에 구부러짐 -&gt; 2회 로테이션, 그림에서는 그림 3의 y가 리턴됨
</span>            <span class="n">w</span> <span class="o">=</span> <span class="n">v</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">parent</span> <span class="c1"># 그림 3에서 w는 v로, y자리에 w가 있어야함. (수정.) w가 v를 한 자리 뒤에서 따라가는 형태
</span></code></pre></div></div>

<ul>
  <li>AVL정리
    <ul>
      <li>높이 &lt;= 2logn =&gt; O(logn)</li>
      <li>insert - 노드 삽입 O(logn) + rebalance(1회 및 2회) O(1) =&gt; O(logn)</li>
      <li>delete - 노드 제거 O(logn) + rebalance(최악의 경우 O(logn)) =&gt; O(logn)</li>
    </ul>
  </li>
</ul>

<h4 id="red-black-tree">Red-Black tree</h4>

<ul>
  <li>가장 유명하고 많이 사용되는 균형이진탐색트리.</li>
</ul>

<p><img src="/assets/images/red-black.png" width="60%" height="60%" /></p>

<ul>
  <li>
    <p>NIL노드 == NULL노드, NULL 안쪽 노드는 내부노드로 불림.</p>
  </li>
  <li>
    <p>특징</p>

    <ol>
      <li>노드들은 red or black의 색만 가진다.</li>
      <li>root노드는 black이다.</li>
      <li>leaf노드 (NULL노드)는 black이다</li>
      <li>red노드는 두개의 자식노드를 가진다 (NULL 노드도 표기하기 때문) + red노드는 자식을 black만 가질 수 있다.</li>
      <li>각 노드에서 leaf노드로 가는 경로들 사이에 <strong>거치는 black노드의 개수가 동일해야한다</strong> - height가 평균 logn시간에 만들어진다는 것을 증명할 때 이용</li>
    </ol>
  </li>
  <li>
    <p>정의</p>

    <ul>
      <li>h(v) = v의 높이 (height)</li>
      <li>bh(v) = v에서 leaf까지 가는 동안 만나는 black노드의 갯수 <strong>(v는 제외해야함.)</strong></li>
    </ul>
  </li>
  <li>
    <p>증명</p>
    <ol>
      <li>v의 서브트리의 내부노드 갯수 &gt;= 2^(bh(v)) - 1
        <ul>
          <li>h(v)에 대한 귀납법을 통해 증명 (induction)</li>
          <li>Base case =&gt; h(v)=0 -&gt; v의 내부노드 갯수 &gt;= 2^0 - 1 =&gt; 성립</li>
          <li>
            <table>
              <tbody>
                <tr>
                  <td>Hypothesis phase =&gt; h(v) &lt;= k에 대하여 **</td>
                  <td>v의 서브트리</td>
                  <td>&gt;= 2^bh(v) - 1**임을 가정</td>
                </tr>
              </tbody>
            </table>
          </li>
          <li>
            <table>
              <tbody>
                <tr>
                  <td>귀납법 시작. -&gt; h(v) = k + 1일때 **</td>
                  <td>v의 서브트리</td>
                  <td>&gt;= 2^bh(v) - 1**이 성립함을 증명</td>
                </tr>
              </tbody>
            </table>
          </li>
          <li>bh(w) &amp; bh(z) = {bh(v) or bh(v-1)}
            <ul>
              <li>pf) bh(v)로부터 w또는 z를 거쳐 만나는 black node의 수들을 생각하면, w또는 z가 black노드인 경우를 제외하면 만나는 black 노드의 수가 모두 동일하다.</li>
            </ul>
          </li>
          <li>
            <table>
              <tbody>
                <tr>
                  <td>따라서,</td>
                  <td>v의 subtree내부노드 수</td>
                  <td>&gt;= 2^bh(w) - 1 + 2^bh(z) - 1 + 1 = 2^bh(v) - 1</td>
                </tr>
              </tbody>
            </table>
          </li>
          <li>
            <table>
              <tbody>
                <tr>
                  <td>-&gt;</td>
                  <td>v의 subtree의 내부노드 수</td>
                  <td>&gt;= 2^bh(v) - 1임을 결국 증명!!!!</td>
                </tr>
              </tbody>
            </table>
          </li>
        </ul>
      </li>
      <li>black 노드 수(root로부터 leaf까지 가는동안 만나는 black노드 수 - bh(root)) &gt;= h/2 (red보다 black노드가 더 많을 수 없음. ) - red자식노드는 무조건 black 노드여야 하기 때문
        <ul>
          <li>r의 subtree의 내부노드 개수 == 전체 red-black tree의 전체 노드 수 &gt;= 2^bh(root) - 1 &gt;= 2^(h/2) - 1</li>
          <li>n &gt;= 2^(h/2) - 1</li>
          <li>h/2 &lt;= log2(n+1) -&gt; h &lt;= 2log2(n+1)</li>
          <li><strong>결론</strong> =&gt; h = O(log2(n)) =&gt; red-black노드는 BST이다 !!</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<p><img src="/assets/images/black-height.jpg" width="60%" height="60%" /></p>

<h4 id="red-black트리의-삽입연산">Red-Black트리의 삽입연산</h4>

<ul>
  <li>BST의 insert연산을 호출 - 새로운 노드를 삽입(x)</li>
  <li>x.color = red</li>
  <li>4가지 경우로 나누어 조정.</li>
</ul>

<p><img src="/assets/images/rbinsert.png" height="60%" width="60%" /></p>

<ul>
  <li>
    <p>경우</p>

    <ol>
      <li>empty red-black트리에 x를 삽입
        <ul>
          <li>red로 삽입했던 x를 black으로 바꾸기 - x.color = black</li>
        </ul>
      </li>
      <li>x.parent.color == black
        <ul>
          <li>do nothing</li>
        </ul>
      </li>
      <li>x.parent.color == red
        <ol>
          <li>x.uncle.color == red인 경우 (uncle =&gt; parent노드의 형제 노드)
            <ul>
              <li>grandparent노드는 black이어야 함.(parent노드가 red인 상황이기때문)</li>
              <li>grandparent.color = red로 변경한 뒤 parent노드를 red에서 black, uncle노드를 red에서 black으로 바꾼다</li>
              <li>색이 red으로 변한 grandparent입장에서, leaf까지 내려가는 동안 만나는 black노드의 수는 변하지 않는다 (원래 grandparent 자신에게 있던 black을 parent와 uncle에게 주었기 때문)</li>
              <li>색이 black으로 변한 parent 입장에서, leaf까지 내려가는 동안 만나는 black노드의 수는 +1로 변한다.</li>
              <li>uncle도 parent와 마찬가지</li>
              <li>parent와 uncle입장에서 black노드의 개수가 증가했다고 해도, 전체적으로 보면 black노드 수가 동일하기 때문에 괜찮다</li>
            </ul>
          </li>
          <li>x.uncle.color == black인 경우
            <ol>
              <li>x - parent - grandparent : linear인 경우
                <ul>
                  <li>grandparent에서 right rotation을 진행</li>
                  <li>grandparent의 색을 red로 변경 -&gt; 색 조건 + 거쳐가는 black노드 수 동일</li>
                </ul>
              </li>
              <li>x- parent - grandparent : triangle인 경우
                <ul>
                  <li>parent에서 left rotation</li>
                  <li>grandparent에서 right rotation</li>
                  <li>grandparent를 red로 변경 -&gt; 색 조건 + 거쳐가는 black 노드 수 동일</li>
                </ul>
              </li>
            </ol>
          </li>
        </ol>
      </li>
    </ol>
  </li>
  <li>
    <p>수행시간</p>

    <ul>
      <li>회전은 최대 2번 : O(1)</li>
      <li>색깔을 조정 : O(1)</li>
      <li>최종 O(logn) - BST class에서 가져온 insert 수행시간이 O(logn)이기 때문 !</li>
    </ul>
  </li>
  <li>
    <p>delete의 수행시간도 O(logn)에 가능하다.</p>

    <ul>
      <li>회전 수는 상수이지만, deleteByMerging or copy연산 자체가 logn시간.</li>
    </ul>
  </li>
  <li>
    <p>AVL vs Red-Black rotation수</p>

    <ul>
      <li>search - -</li>
      <li>insert 2 2</li>
      <li>delete O(logn) 3</li>
    </ul>
  </li>
  <li>
    <p><a href="https://ko.wikipedia.org/wiki/%EB%A0%88%EB%93%9C-%EB%B8%94%EB%9E%99_%ED%8A%B8%EB%A6%AC">Red - Black트리 위키</a></p>
  </li>
</ul>

<h4 id="234트리---red-black트리와의-관계가-밀접한-트리">2,3,4트리 - Red Black트리와의 관계가 밀접한 트리</h4>

<ul>
  <li>2,3,4트리 조건
    <ol>
      <li>자식노드의 개수가 2,3,4개중 하나</li>
      <li>모든 leaf node가 같은 level에 존재</li>
    </ol>
  </li>
  <li>2-노드, 3-노드, 4-노드</li>
</ul>

<p><img src="/assets/images/two.png" height="60%" width="60%" /></p>

<ul>
  <li>
    <p>노드 search방법</p>

    <ul>
      <li>search(53) -&gt; a &lt;= b &lt;= c인 자식 노드와 비교하면 됨. =&gt;4갈래</li>
    </ul>
  </li>
  <li>
    <p>높이</p>

    <ul>
      <li>root를 제외한 모든 자식노드가 4개인 경우 - log4(n)</li>
      <li>root를 제외한 모든 자식노드가 2개인 경우 - log2(n)</li>
      <li>h = O(log2(n))인 균형탐색트리 (<strong>이진트리 아님!!</strong>)</li>
    </ul>
  </li>
  <li>
    <p>insert(key)</p>
    <ul>
      <li>search해나가다가, 삽입할 공간이 있으면 삽입</li>
      <li><strong>4-노드를 만나면 split하면서 리프노드까지 내려감</strong> - insert될 key가 search하려고 노드에 들어가봤더니 4-노드가 된 경우를 4-노드와 만났다고 표현</li>
      <li>[a,b,c] 노드가 있을때, b를 부모로 보내고 a와 c로 쪼개는 연산이 split (one split -&gt; O(1))</li>
      <li>모든 level에서 split이 발생 -&gt; h가 O(logn)이므로 insert연산도 O(logn)</li>
      <li>루트노드가 4-노드가 되면 height가 증가하게됨.</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/images/split.png" width="60%" height="60%" /></p>

<ul>
  <li>
    <p>delete(key)</p>

    <ul>
      <li><a href="https://en.wikipedia.org/wiki/2%E2%80%933%E2%80%934_tree">2-3-4 tree wiki 中 Deletion 발췌</a></li>
      <li>삭제할 key값이 트리 내부에는 존재하는데, leaf node에 있을수도 없을수도 있다.</li>
      <li>삭제할 key값이 leaf node에 없는 경우 successor연산을 통해 삭제 대상인 key값보다 큰 <strong>바로 다음 수를 찾는다</strong></li>
      <li>successor는 항상 leaf node에 있으며, successor가 없으면 key보다 작은 <strong>바로 이전 수를 찾는다</strong></li>
      <li>successor를 찾았으면 삭제 대상인 key값과 swap후 key를 삭제</li>
      <li>어쨌든 key값을 가진 노드는 swap하던 원래 leaf node에 있던 leaf node에 있을 것이기 때문에 leaf node에 있다고 가정하자.</li>
    </ul>
  </li>
  <li>
    <p>delete의 경우, 사진에서 70key를 가진 노드를 지운다면 70의 부모인 80노드가 자식노드를 하나밖에 갖지 못한다. =&gt; <strong>2-3-4 tree 정의에 위배</strong></p>
    <ul>
      <li>삭제할 노드를 찾아 search하는 과정에서, 루프-&gt;리프까지 가는 동안 2-노드를 만나면 3-노드로 바꾼다 (그림 보고 흐름 이해해보기)</li>
      <li>왼쪽 그림의 경우 30노드 기준 형제 노드로부터 자신을 3-노드로 바꿀 수 있게끔 노드를 꿔올 수 있는지 본다. -&gt; 30노드 3-노드로 바꿔줌</li>
      <li>오른쪽 그림의 경우 30노드 기준 형제 노드를 보니, 형제 노드들도 모두 2-노드여서 꿔올 수 없는 상황 =&gt; 부모의 key와 적당히 병합하여 3 or 4-노드로 만들어준다 -&gt; <strong>fusion</strong></li>
      <li>root노드 입장에서 자식노드를 3 or 4노드를 만드는 연산은 없으며, root의 자식 노드 모두 2-노드라면 root와 자식노드들을 fusion한다! =&gt; height가 줄어듦</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/images/deletetwo.png" height="60%" width="60%" /></p>

<ul>
  <li>delete수행시간
    <ul>
      <li>fusion이 레벨마다 일어나면 -&gt; O(logn)시간</li>
    </ul>
  </li>
</ul>

<h4 id="2-3-4트리와-red-black트리의-관계성">2-3-4트리와 Red-black트리의 관계성</h4>

<ul>
  <li><a href="https://stackoverflow.com/questions/35955246/converting-a-2-3-4-tree-into-a-red-black-tree">Converting a 2-3-4 tree into a red black tree</a></li>
  <li>
    <p>2-3-4에서 Red-black으로</p>

    <ol>
      <li>2-node -&gt; black으로</li>
      <li>3-node -&gt; 2 level에 걸쳐서 쪼개기. 쪼갠 뒤 색 부여 (첫번째 레벨에 black, 두번째 레벨에 red)</li>
      <li>4-node도 2 level에 걸쳐 쪼개기 (첫번째 레벨에 black, 두번째 레벨에 red)</li>
    </ol>

    <ul>
      <li><strong>만약, 3-node나 4-node가 red-black트리로 변환되면서 만들어내는 black노드의 수에 차이가 있다면, ex) 3-node는 1개 만들어내는데 4-node는 2개를 만들어낸다면, root로부터 쭉 내려올때 left subtree에 3-노드를 포함하고, right subtree에 4-노드를 포함하는 경우 red-black트리의 대전제를 깨게 됨</strong></li>
      <li>3-node도, 4-node도 레드 블랙트리로 변환하면 레벨당 하나씩 블랙노드를 매핑하기때문에 문제가 발생하지 않음!!!</li>
    </ul>
  </li>
  <li>2-3-4 tree의 높이를 h, 이에 대응되는 red-black tree의 높이를 h’이라고 하자
    <ul>
      <li>log4(n) &lt;= h &lt;= log2(n)임은 위에서 확인했었음.</li>
      <li>높이가 h인 2-3-4트리를 red-black으로 대응시킬때, 최악의경우 2-3-4트리 모두가 3-node로 이루어져있는 것 -&gt; 두 레벨로 쪼개져서 대응됨.</li>
      <li>결론적으로, h’ &lt;= 2*h가 되고, h’ &lt;= 2*log3(n) = (2/log2(3))*log2(n) = 1.261*log2(n)</li>
    </ul>
  </li>
</ul>
</section>
</main>


    <script src="https://use.fontawesome.com/releases/v5.15.3/js/all.js"></script>
    <!-- JavaScript Bundle with Popper -->
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js"
      integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM"
      crossorigin="anonymous"
    ></script>
    <script src="assets/js/sidebar-click-event.js"></script>
    <script src="//code.jquery.com/jquery-3.3.1.min.js"></script>
  </body>
</html>
